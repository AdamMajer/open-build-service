#!/usr/bin/perl -w
#
# Copyright (c) 2020 Adrian Schroeter, SUSE LLC
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program (see the file COPYING); if not, write to the
# Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA
#
################################################################
#
# optional source publishing process
#

BEGIN {
  my ($wd) = $0 =~ m-(.*)/- ;
  $wd ||= '.';
  unshift @INC,  "$wd";
}

use XML::Structured ':bytes';
use POSIX;

use BSConfiguration;
use BSUtil;
use BSSrcrep;
use BSRevision;
use BSStdRunner;
use BSSQLite;
use BSVerify;
use Data::Dumper;

use strict;

my $eventdir = "$BSConfig::bsdir/events";
my $srcrep = "$BSConfig::bsdir/sources";
my $rundir = $BSConfig::rundir || $BSConfig::rundir || "$BSConfig::bsdir/run";
my $uploaddir = "$srcrep/:upload";

my $rsyncserver = $BSConfig::sourcepublish_sync || $BSConfig::sourcepublish_sync;

my $maxchild = 1;
$maxchild = $BSConfig::sourcepublish_maxchild if defined $BSConfig::sourcepublish_maxchild;

my $myeventdir = "$eventdir/sourcepublish";

# source publish db init
my $publishedsourcedbfile = "$BSConfig::bsdir/db/sqlite/publishedsource";
my $publishedsourcedb;

sub init_db {
  my ($conf) = @_;
  mkdir_p("$BSConfig::bsdir/db/sqlite");
  $publishedsourcedb = BSSQLite::connectdb($publishedsourcedbfile);
  my %dbtables = map {$_ => 1} BSSQLite::list_tables($publishedsourcedb);
  if (!$dbtables{'publishedsource'}) {
    BSSQLite::dbdo($publishedsourcedb, <<'EOS');
  CREATE TABLE IF NOT EXISTS publishedsource(
    project TEXT,
    package TEXT,
    srcmd5 TEXT,
    UNIQUE(project,package,srcmd5)
  )
EOS
  }
  BSSQLite::dbdo($publishedsourcedb, 'CREATE INDEX IF NOT EXISTS publishedsource_idx on publishedsource(project,package,srcmd5)');
  BSRunner::run($conf);
}

sub getrev {
  my ($projid, $packid, $revid) = @_;
  my $rev = BSRevision::getrev_local($projid, $packid, $revid);
  $rev = BSRevision::getrev_deleted_srcmd5($projid, $packid, $revid) if !$rev && $revid && $revid =~ /^[0-9a-f]{32}$/;
  return $rev;
}

sub linksourceintodir {
  my ($basedir, $projid, $packid, $srcmd5) = @_;

  # get files to send to service daemon
  my $rev;
  my $sourcefiles;
  eval {
   $rev = getrev($projid, $packid, $srcmd5);
   $sourcefiles = BSRevision::lsrev($rev);
  };
  if ($@) {
    BSUtil::printlog "warning: $projid, $packid, $srcmd5 not found, skipping\n";
    return;
  }

  my $dir = "$basedir/$projid/$packid/$srcmd5";
  mkdir_p("$dir");
  for my $filename (sort keys %$sourcefiles) {
    link(BSRevision::revfilename($rev, $filename, $sourcefiles->{$filename}), "$dir/$filename");
  }
  return 1;
}

sub qsystem {
  my @args = @_;
  my $pid;
  local (*RH, *WH);
  if ($args[0] eq 'echo') {
    pipe(RH, WH) || die("pipe: $!\n");
  }
  if (!($pid = xfork())) {
    if ($args[0] eq 'echo') {
      close WH;
      open(STDIN, "<&RH");
      close RH;
      splice(@args, 0, 2);
    }
    if ($args[0] eq 'chdir') {
      chdir($args[1]) || die("chdir $args[1]: $!\n");
      splice(@args, 0, 2);
    }
    if ($args[0] eq 'stdout') {
      if ($args[1] ne '') {
        open(STDOUT, '>', $args[1]) || die("$args[1]: $!\n");
      }
      splice(@args, 0, 2);
    } else {
      open(STDOUT, ">/dev/null");
    }
    eval {
      exec(@args);
      die("$args[0]: $!\n");
    };
    warn($@) if $@;
    exit 1;
  }
  if ($args[0] eq 'echo') {
    close RH;
    print WH $args[1];
    close WH;
  }
  waitpid($pid, 0) == $pid || die("waitpid $pid: $!\n");
  return $?;
}

sub add_publishedsource {
  my ($projid, $packid, $srcmd5) = @_;

  my $h = $publishedsourcedb->{'sqlite'} || BSSQLite::connectdb($publishedsourcedbfile);
  BSSQLite::begin_work($h);
  BSSQLite::dbdo_bind($h, 'INSERT INTO publishedsource(project,package,srcmd5) VALUES(?,?,?)', [ $projid ], [ $packid ], [ $srcmd5 ]);
  BSSQLite::commit($h);
}

sub has_publishedsource {
  my ($projid, $packid, $srcmd5) = @_;

  my $h = $publishedsourcedb->{'sqlite'} || BSSQLite::connectdb($publishedsourcedbfile);
  my @ary = BSSQlite::selectrow($h, "project,package,srcmd5 FROM publishedsource WHERE project = ? AND package = ? AND srcmd5 = ?", $projid, $packid, $srcmd5);
  return $ary[0] ? 1 : 0;
}

sub syncsource {
  my ($dir, $projid, $packid, $srcmd5, $new_entry) = @_;

  my $rsyncpath = "$rsyncserver";
  $rsyncpath =~ s/^rsync://;

  my @rsync_extra_options;
  @rsync_extra_options = split(' ', $BSConfig::rsync_extra_options) if $BSConfig::rsync_extra_options;
  qsystem('echo', "$projid/$packid/$srcmd5\0", 'rsync', '-ar0', @rsync_extra_options, '--fuzzy', '--timeout', '7200', '--files-from=-', $dir, $rsyncpath) && die("    rsync failed at ".localtime(time).": $?\n");

  add_publishedsource($projid, $packid, $srcmd5) if $new_entry;
}

sub sourcepublish {
  my ($projid, $packid, $srcmd5, $included) = @_;

  return unless $BSConfig::sourcepublish_sync && $BSConfig::sourcepublish_sync =~ /^rsync:\//;
  if ($BSConfig::sourcepublish_filter) {
    my $match;
    for my $filter (@{$BSConfig::sourcepublish_filter||[]}) {
      $match = 1 if $projid =~ /^$filter/;
    }
    return unless $match;
  }

  BSUtil::printlog("source publish event for $projid/$packid $srcmd5");

  my $update;
  my $new_entry = has_publishedsource($projid, $packid, $srcmd5);

  # get files to send to service daemon
  my $odir = "$uploaddir/sourcepublish$$/";
  BSUtil::cleandir("$odir") if -d $odir;
  # strip multibuild flavor
  $packid =~ s/:.*// if $packid =~ /(?<!^_product)(?<!^_patchinfo):./;
  linksourceintodir($odir, $projid, $packid, $srcmd5) || die ("unable to link sources for $projid $packid $srcmd5");

  # check for included sources, eg in images
  for my $source (@{$included || []}) {
    my $package = $source->{'package'};
    # strip multibuild flavor
    $package =~ s/:.*// if $package =~ /(?<!^_product)(?<!^_patchinfo):./;
    my $exists = has_publishedsource($source->{'project'}, $package, $source->{'srcmd5'});
    my $created;
    unless ($exists) {
      if (linksourceintodir($odir, $source->{'project'}, $package, $source->{'srcmd5'})) {
        syncsource($odir, $source->{'project'}, $package, $source->{'srcmd5'});
        $created = 1;
      }
    }
    if ($exists || $created) {
      my $symlink = "$odir/$projid/$packid/$srcmd5/INCLUDED";
      mkdir_p($symlink);
      $symlink .= "/$source->{'project'}::${package}::$source->{'srcmd5'}";
      if ( ! -e $symlink ) {
        symlink("../../../../$source->{'project'}/$package/$source->{'srcmd5'}", $symlink) || die("symlink creation failed for $symlink: $!");
      }
      $update = 1;
    }
  }

  # sync main package
  syncsource($odir, $projid, $packid, $srcmd5, $new_entry) if $update || $new_entry;

  BSUtil::cleandir($odir);
  rmdir($odir);
}

sub getevent {
  my ($req, $notdue, $nofork) = BSStdRunner::getevent(@_);
  return ($req, $notdue, $nofork);
}

sub sourcepublishevent {
  my ($req, @args) = @_;
  eval {
    sourcepublish(@args);
  };
  if ($@) {
    # retry in 10 minutes
    BSStdRunner::setdue($req, time() + 10 * 60);
    die($@);
  }
  return 1;
}

my $dispatches = [
  'sourcepublish $project $package $srcmd5 $included:*' => \&sourcepublishevent,
];

my $conf = {
  'run' => \&init_db,
  'eventdir' => $myeventdir,
  'dispatches' => $dispatches,
  'maxchild' => $maxchild,
  'getevent' => \&getevent,
  'inprogress' => 1,
};

BSStdRunner::run('bs_sourcepublish', \@ARGV, $conf);
